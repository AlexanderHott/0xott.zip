---
createdAt: 2025-11-24T22:16:13.210Z
title: "Methods"
tags:
  - language-design
description: "..."
draft: true
---

disclaimer about "readability"

Sometimes method chaining is good, sometimes its bad.

talk about

```rs
let x = 10usize;
let y = is_coprime(x, 257usize.next_power_of_two()).bitxor(is_prime(257));

let z = x
    :is_coprime(
    257usize.next_power_of_two()
    )
    .bitxor(is_prime(257));

let x_is_coprime = is_coprime(x, 257usize.next_power_of_two());
let other_is_prime = is_prime(257);
let prime_and_coprime_different = x_is_coprime ^ other_is_prime;
```

Methods are great, and method chaining is one of the most readable forms of
syntax for _repeated function application_ that exists.

(Even math people made a notation for it: $y = (c \circ b \circ a)(x)$)

You might know the three main contenders:

```rs
// c-style plain functions
let y = c(b(a(x)));

// method chaining
let y = x.a().b().c();

// piping
let y = x |> a() |> b() |> c()
```

(The `|>` may display as a ligature of the `|` and `>` characters.)

plain functions are really bad for readability, you need to go to the center of
the line, and when there are multiple arguments and multiple lines, it gets
really messy.

method chaining and pipes pretty much have the same "readability"

TODO: reorder functions so method chaining and piping have the first -> second
-> thrid order

```rs
let y = a_really_long_funciton(
    argument_1,
    argument2,
    argument_3,
    another_really_long_function(
        argument_4,
        argument_5,
        a_third_really_long_function(x),
    ),
);

let y = x
    .a_third_really_long_function()
    .another_really_long_function(
        argument_4,
        argument_5,
    )
    .a_really_long_funciton(
        argument_1,
        argument2,
        argument_3,
    );

let y = x
    |> a_third_really_long_function()
    |> another_really_long_function(
        argument_4,
        argument_5,
    )
    |> a_really_long_funciton(
        argument_1,
        argument2,
        argument_3,
    );
```

However, a challenge arises when you need to implement functions for "foreign
types" (as rust calls it)

How do I implement the `i32::is_coprime(other: i32) -> bool` method on a type?

In rust, you can't. You must use a wrapper type, or a plain function. The
wrapper type falls apart quickly; you end up with a mix of methods and
functions.

```rs
let y = is_coprime(
    x,
    257.next_power_of_two()
).xor(is_prime(257))

let y = x
    |> is_coprime(257.next_power_of_two())
    .xor(x |> is_prime())
```

However, this is still a bit wonky. Roc may introduce the `->` operator. No, its
not dereference and fixed offset like C and C++, its the pipe operator but for
method chaining.

```rs
let y = x
    ->is_coprime(257.next_power_of_two())
    .xor(x->is_prime())
```

It is an objective fact that the difference in C and C++ is useless, because you
can only ever use the `.` or the `->`, not both. The compiler should fix this
for you. (CLion, does fix it for you. If you press `.` and then press enter on a
struct field, it will change the `.` to a `->` if it is behind a reference.)

However, in Roc, you could have a method with `.`, or a function with `->`.

[https://roc.zulipchat.com/#narrow/channel/304641-ideas/topic/static.20dispatch.20-.20pass_to.20alternative/near/490730736](https://roc.zulipchat.com/#narrow/channel/304641-ideas/topic/static.20dispatch.20-.20pass_to.20alternative/near/490730736)

```rs
let y = ...;
```

```rs
main! = |_|
    "./input.txt"
    .>Path.from_str()
    .read_bytes!()?
    .>Foo.from_bytes()?
    .>transform(2, Much)
    .to_bytes()?
    .>Path.write_bytes!(Path.from_str("./output.txt"))

main! = |_|
    "./input.txt"
    |>Path.from_str()
    .read_bytes!()?
    |>Foo.from_bytes()?
    |>transform(2, Much)
    .to_bytes()?
    |>Path.write_bytes!(Path.from_str("./output.txt"))

main! = |_|
    "./input.txt"
    ->Path.from_str()
    .read_bytes!()?
    ->Foo.from_bytes()?
    ->transform(2, Much)
    .to_bytes()?
    ->Path.write_bytes!(Path.from_str("./output.txt"))

main! = |_|
    "./input.txt"
   ->Path.from_str()
    .read_bytes!()?
   ->Foo.from_bytes()?
   ->transform(2, Much)
    .to_bytes()?
   ->Path.write_bytes!(Path.from_str("./output.txt"))

let y =
    "./input.txt"
    →Path.from_str()
    .read_bytes!()?
    →Foo.from_bytes()?
    →transform(2, Much)
    .to_bytes()?
    →Path.write_bytes!(Path.from_str("./output.txt"))

main! = |_|
    "./input.txt"
    :Path.from_str()
    .read_bytes!()?
    :Foo.from_bytes()?
    :transform(2, Much)
    .to_bytes()?
    :Path.write_bytes!(Path.from_str("./output.txt"))

main! = |_|
    "./input.txt"
    .Path::from_str()
    .read_bytes!()?
    .Foo::from_bytes()?
    .transform(2, Much)
    .to_bytes()?
    .Path::write_bytes!(Path::from_str("./output.txt"))
```

Why can't you just use `.`?
[roc zulip](https://roc.zulipchat.com/#narrow/channel/304641-ideas/topic/static.20dispatch.20-.20pass_to.20alternative/near/499385130)

fp - oop
